{"version":3,"sources":["SortingVisualizer/sortingAlgorithms.js","SortingVisualizer/quickSort.js","SortingVisualizer/SortingVisualizer.js","App.js","serviceWorker.js","index.js"],"names":["getMergeSortAnimations","array","animations","length","auxiliaryArray","slice","mergeSortHelper","mainArray","startIdx","endIdx","middleIdx","Math","floor","k","i","j","push","doMerge","QuickSort","arr","index","left","right","middle","pivot","partition","executing","sleep","ms","Promise","resolve","setTimeout","SortingVisualizer","props","state","AnimationSpeed","title","className","NUMBER_OF_ARRAY_BARS","barHeight","disabledSlider","params","this","setState","target","value","resetArray","console","log","min","max","random","arrayBars","document","getElementsByClassName","a","style","backgroundColor","checkExecution","barOneIndex","barTwoIndex","barOneStyle","barTwoStyle","color","newHeight","height","len","swap","indx1","indx2","indxOfMin","parseInt","leftStyle","rightStyle","heap_root","heapSort","input","array_length","index_A","index_B","temp","temp1","temp2","b","type","step","disabled","onChange","e","barAmount","SetAnimationSpeed","onClick","bubbleSort","insertionSort","selectionSort","mergeSort","quickSort","map","idx","key","React","Component","App","Boolean","window","location","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.dd299c91.chunk.js","sourcesContent":["export function getMergeSortAnimations(array) {\r\n  const animations = [];\r\n  if (array.length <= 1) return array;\r\n  const auxiliaryArray = array.slice();\r\n  mergeSortHelper(array, 0, array.length - 1, auxiliaryArray, animations);\r\n  return animations;\r\n}\r\n\r\nfunction mergeSortHelper(\r\n  mainArray,\r\n  startIdx,\r\n  endIdx,\r\n  auxiliaryArray,\r\n  animations,\r\n) {\r\n  if (startIdx === endIdx) return;\r\n  const middleIdx = Math.floor((startIdx + endIdx) / 2);\r\n  mergeSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray, animations);\r\n  mergeSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray, animations);\r\n  doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations);\r\n}\r\n\r\nfunction doMerge(\r\n  mainArray,\r\n  startIdx,\r\n  middleIdx,\r\n  endIdx,\r\n  auxiliaryArray,\r\n  animations,\r\n) {\r\n  let k = startIdx;\r\n  let i = startIdx;\r\n  let j = middleIdx + 1;\r\n  while (i <= middleIdx && j <= endIdx) {\r\n    // These are the values that we're comparing; we push them once\r\n    // to change their color.\r\n    animations.push([i, j]);\r\n    // These are the values that we're comparing; we push them a second\r\n    // time to revert their color.\r\n    animations.push([i, j]);\r\n    if (auxiliaryArray[i] <= auxiliaryArray[j]) {\r\n      // We overwrite the value at index k in the original array with the\r\n      // value at index i in the auxiliary array.\r\n      animations.push([k, auxiliaryArray[i]]);\r\n      mainArray[k++] = auxiliaryArray[i++];\r\n    } else {\r\n      // We overwrite the value at index k in the original array with the\r\n      // value at index j in the auxiliary array.\r\n      animations.push([k, auxiliaryArray[j]]);\r\n      mainArray[k++] = auxiliaryArray[j++];\r\n    }\r\n  }\r\n  while (i <= middleIdx) {\r\n    // These are the values that we're comparing; we push them once\r\n    // to change their color.\r\n    animations.push([i, i]);\r\n    // These are the values that we're comparing; we push them a second\r\n    // time to revert their color.\r\n    animations.push([i, i]);\r\n    // We overwrite the value at index k in the original array with the\r\n    // value at index i in the auxiliary array.\r\n    animations.push([k, auxiliaryArray[i]]);\r\n    mainArray[k++] = auxiliaryArray[i++];\r\n  }\r\n  while (j <= endIdx) {\r\n    // These are the values that we're comparing; we push them once\r\n    // to change their color.\r\n    animations.push([j, j]);\r\n    // These are the values that we're comparing; we push them a second\r\n    // time to revert their color.\r\n    animations.push([j, j]);\r\n    // We overwrite the value at index k in the original array with the\r\n    // value at index j in the auxiliary array.\r\n    animations.push([k, auxiliaryArray[j]]);\r\n    mainArray[k++] = auxiliaryArray[j++];\r\n  }\r\n}\r\n","var animations = []\r\n\r\nfunction QuickSort(arr, left = 0, right = arr.length - 1) {\r\n  let len = arr.length,\r\n    index\r\n\r\n  if (len > 1) {\r\n\r\n    index = partition(arr, left, right)\r\n\r\n    if (left < index - 1) {\r\n      QuickSort(arr, left, index - 1)\r\n    }\r\n    if (index < right) {\r\n      QuickSort(arr, index, right)\r\n    }\r\n  }\r\n  return arr\r\n}\r\n\r\nfunction partition(arr, left, right) {\r\n  let middle = Math.floor((right + left) / 2)\r\n  let pivot = arr[middle]\r\n  let i = left\r\n  let j = right\r\n\r\n  while (i <= j) {\r\n    while (arr[i] < pivot) {\r\n      i++\r\n    }\r\n    while (arr[j] > pivot) {\r\n      j--\r\n    }\r\n    if (i <= j) {\r\n      [arr[i], arr[j]] = [arr[j], arr[i]]  // ES6 destructuring swap\r\n      animations.push([i, j])\r\n      i++\r\n      j--\r\n    }\r\n  }\r\n  return i\r\n}\r\n\r\nexport function quicksortHelper(arr) {\r\n  animations=[]\r\n  QuickSort(arr)\r\n  return animations\r\n}\r\n\r\n// var testArray = [ 260, 255, 250, 245, 240, 235, 230, 225, 220, 215, 210, 205, 200, 195, 190, 185, 180, 175, 170, 165, 160, 155, 150, 145, 140, 135, 130, 125, 120, 115, 110, 105, 100, 95, 90, 85, 80, 75, 70, 65, 60, 55, 50, 45, 40, 35, 30, 25, 20, 15, 10, 5, 500, 495, 490, 485, 480, 475, 470, 465, 460, 455, 450, 445, 440, 435, 430, 425, 420, 415, 410, 405, 400, 395, 390, 385, 380, 375, 370, 365, 360, 355, 350, 345, 340, 335, 330, 325, 320, 315, 310, 305, 300, 295, 290, 285, 280, 275, 270, 265];\r\n// console.log(QuickSort(testArray));\r\n","import React from 'react';\r\nimport { getMergeSortAnimations } from './sortingAlgorithms.js';\r\nimport { quicksortHelper } from './quickSort'\r\nimport './SortingVisualizer.css';\r\n\r\n// Change this value for the speed of the animations.\r\n\r\nlet executing = true;\r\n\r\n// console.log(slider)\r\n// This is the main color of the array bars.\r\nconst PRIMARY_COLOR = 'turquoise';\r\n\r\n// This is the color of array bars that are being compared throughout the animations.\r\nconst SECONDARY_COLOR = 'red';\r\n\r\n// have to promisify the setTimeout Method so we can use it with async await.\r\nconst sleep = ms => new Promise(resolve => setTimeout(resolve, ms))\r\n\r\nexport default class SortingVisualizer extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n\r\n        this.state = {\r\n            array: [],\r\n            AnimationSpeed: 10,\r\n            title: <h1 className=\"description\">Select a sort!</h1>,\r\n            NUMBER_OF_ARRAY_BARS: 50,\r\n            barHeight: 700,\r\n            disabledSlider: false\r\n        }\r\n    }\r\n\r\n    async barAmount(params) {\r\n        await this.setState({\r\n            NUMBER_OF_ARRAY_BARS: params.target.value\r\n        })\r\n        this.resetArray()\r\n    }\r\n\r\n    async barHeight(params) {\r\n        await this.setState({\r\n            barHeight: params.target.value\r\n        })\r\n        this.resetArray()\r\n    }\r\n\r\n    async SetAnimationSpeed(params) {\r\n        console.log(params.target.value)\r\n        await this.setState({\r\n            AnimationSpeed: params.target.value\r\n        })\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.resetArray();\r\n    }\r\n\r\n    async resetArray() {\r\n        executing = false\r\n        let array = []\r\n        for (let i = 0; i < this.state.NUMBER_OF_ARRAY_BARS; i++) {\r\n            array.push(randomIntFromInterval(5, this.state.barHeight));\r\n        }\r\n        this.setState({\r\n            array,\r\n            disabledSlider: false,\r\n            title: <h1 className=\"description\">Select a sort!</h1>\r\n        });\r\n        this.setState({})\r\n        const arrayBars = document.getElementsByClassName('array-bar');\r\n        for (let a = 0; a < arrayBars.length; a++) {\r\n            arrayBars[a].style.backgroundColor = \"turquoise\"\r\n        }\r\n    }\r\n\r\n    async checkExecution() {\r\n        executing = false\r\n        this.setState({ disabledSlider: true })\r\n        await this.resetArray();\r\n        await sleep(500)\r\n        executing = true\r\n        console.log('executing: ' + executing)\r\n    }\r\n\r\n    async mergeSort() {\r\n        await this.checkExecution()\r\n        this.setState({\r\n            title: (<div className=\"description\">\r\n                <h1 className=\"title\">Merge Sort</h1>\r\n                <p className=\"explanation\">This sort recursively splits the unsorted array in half until it cant anymore. Then it <i>merges</i> all the halves back together in reverse order, sorting as it goes.</p>\r\n                <h3>Worst complexity:O(n*log(n))</h3>\r\n                <h3>Average complexity: O(n*log(n))</h3>\r\n                <h3>Best complexity: O(n*log(n))</h3>\r\n                <h3>Space complexity: O(n) </h3>\r\n            </div>)\r\n        })\r\n\r\n        const animations = getMergeSortAnimations(this.state.array);\r\n        for (let i = 0; i < animations.length; i++) {\r\n            if (!executing) {\r\n                this.setState({ disabledSlider: false })\r\n                return\r\n            }\r\n            const arrayBars = document.getElementsByClassName('array-bar');\r\n            const isColorChange = i % 3 !== 2;\r\n            if (isColorChange) {\r\n                const [barOneIndex, barTwoIndex] = animations[i];\r\n                const barOneStyle = arrayBars[barOneIndex].style;\r\n                const barTwoStyle = arrayBars[barTwoIndex].style;\r\n                const color = i % 3 === 0 ? SECONDARY_COLOR : PRIMARY_COLOR;\r\n                await sleep(this.state.AnimationSpeed)\r\n                barOneStyle.backgroundColor = color;\r\n                barTwoStyle.backgroundColor = color;\r\n            } else {\r\n                await sleep(this.state.AnimationSpeed)\r\n                const [barOneIndex, newHeight] = animations[i];\r\n                const barOneStyle = arrayBars[barOneIndex].style;\r\n                barOneStyle.height = `${newHeight}px`;\r\n            }\r\n            if (i === animations.length - 1) this.setState({ disabledSlider: false })\r\n        }\r\n    }\r\n\r\n    async selectionSort() {\r\n        await this.checkExecution()\r\n        await sleep(this.state.AnimationSpeed)\r\n        const arr = document.getElementsByClassName('array-bar')\r\n        const len = arr.length\r\n\r\n        //displaying a descrition of the type of sort\r\n        this.setState({\r\n            title: (<div className=\"description\">\r\n                <h1 className=\"title\">Selection Sort</h1>\r\n                <p className=\"explanation\">Finds the smallest element in the array, and putts it at the beginning of the array. Its called selection sort because it marks the lowest value on each pass <i>here in purple</i> then when it reaches the end of each loop, the lowest value is \"selected\" to be swaped to the begining.</p>\r\n                <h3>Color legend</h3>\r\n                Green: Sorted, Grey: Current index being sorted, Yellow: Current scan, Purple: Possible hits\r\n               \r\n                <h3>Worst complexity:O(n^2)</h3>\r\n                <h3>Average complexity: O(n^2)</h3>\r\n                <h3>Best complexity: O(n^2)</h3>\r\n                <h3>Space complexity: O(1) </h3>\r\n            </div>)\r\n        })\r\n\r\n        //setting up an array deconstructor to swap the places passed in\r\n        const swap = (arr, indx1, indx2) =>\r\n            //array deconstructor to define what will be swapped\r\n            ([arr[indx1].style.height, arr[indx2].style.height] = [arr[indx2].style.height, arr[indx1].style.height])\r\n\r\n        //create a loop for the array\r\n        for (let i = 0; i < len; i++) {\r\n            //setting a postion for the index's smallest location\r\n            arr[i].style.backgroundColor = `grey`\r\n            let indxOfMin = i;\r\n            //looping through the rest of the array on top of first position\r\n            for (let j = i + 1; j < len; j++) {\r\n                if (!executing) {\r\n                    console.log('got hit')\r\n                    this.setState({ disabledSlider: false })\r\n                    return\r\n                }\r\n                arr[j].style.backgroundColor = `yellow`\r\n                await sleep(5)\r\n                arr[j].style.backgroundColor = PRIMARY_COLOR\r\n                // checking if the next number in the array is less than our current position and if so setting the index equal to that number \r\n                if (parseInt(arr[j].style.height) < parseInt(arr[indxOfMin].style.height)) {\r\n                    arr[j].style.backgroundColor = `purple`\r\n                    indxOfMin = j\r\n                }\r\n            }\r\n\r\n            if (indxOfMin !== i) {\r\n                console.log(`switch hit`)\r\n                swap(arr, indxOfMin, i)\r\n                //await sleep(100)\r\n            }\r\n            arr[i].style.backgroundColor = `green`\r\n        }\r\n        this.setState({ disabledSlider: false })\r\n        //returns the array newly sorted\r\n        return\r\n    }\r\n\r\n    async quickSort() {\r\n        await this.checkExecution()\r\n        this.setState({\r\n            title: (<div className=\"description\">\r\n                <h1 className=\"title\">Quick Sort</h1>\r\n                <p className=\"explanation\">This sort recursively swaps values on either side of an arbitrary pivot index, in smaller and smaller increments until the whole array is sorted. This sort is the fastest on average, and is therefore considered the fastest sort.</p>\r\n                <h3>Worst complexity:O(n2)</h3>\r\n                <h3>Average complexity: O(n log n)</h3>\r\n                <h3>Best complexity: O(n log n)</h3>\r\n                <h3>Space complexity: O(n) </h3>\r\n            </div>)\r\n        })\r\n        const arrayBars = document.getElementsByClassName('array-bar');\r\n        const animations = quicksortHelper(this.state.array)\r\n        for (let i = 0; i < animations.length; i++) {\r\n            if (!executing) {\r\n                this.setState({ disabledSlider: false })\r\n                return\r\n            }\r\n            console.log('quickSortSwap');\r\n            const [left, right] = animations[i];\r\n            const leftStyle = arrayBars[left].style.height;\r\n            const rightStyle = arrayBars[right].style.height;\r\n\r\n            arrayBars[left].style.backgroundColor = 'red';\r\n            arrayBars[right].style.backgroundColor = 'red';\r\n\r\n            await sleep(this.state.AnimationSpeed)\r\n            arrayBars[left].style.height = rightStyle;\r\n            arrayBars[right].style.height = leftStyle;\r\n            arrayBars[left].style.backgroundColor = 'turquoise';\r\n            arrayBars[right].style.backgroundColor = 'turquoise';\r\n        }\r\n        this.setState({ disabledSlider: false })\r\n    }\r\n\r\n    async heapSort() {\r\n        const arr = document.getElementsByClassName('array-bar')\r\n        let array_length = arr.length\r\n        /* to create MAX  array */\r\n        function heap_root(input, i) {\r\n            var left = 2 * i + 1;\r\n            var right = 2 * i + 2;\r\n            var max = i;\r\n            if (left < array_length && input[left] > input[max]) {\r\n                max = left;\r\n            }\r\n            if (right < array_length && input[right] > input[max]) {\r\n                max = right;\r\n            }\r\n            if (max !== i) {\r\n                swap(input, i, max);\r\n                heap_root(input, max);\r\n            }\r\n        }\r\n\r\n        function swap(input, index_A, index_B) {\r\n            var temp = input[index_A];\r\n\r\n            input[index_A] = input[index_B];\r\n            input[index_B] = temp;\r\n        }\r\n\r\n        function heapSort(input) {\r\n            array_length = input.length;\r\n            for (var i = Math.floor(array_length / 2); i >= 0; i -= 1) {\r\n                heap_root(input, i);\r\n            }\r\n            for (i = input.length - 1; i > 0; i--) {\r\n                swap(input, 0, i);\r\n                array_length--;\r\n                heap_root(input, 0);\r\n            }\r\n        }\r\n        heapSort(arr);\r\n        console.log(arr);\r\n        this.setState({ disabledSlider: false })\r\n    }\r\n\r\n    async insertionSort() {\r\n        await this.checkExecution()\r\n        this.setState({\r\n            title: (<div className=\"description\">\r\n                <h1 className=\"title\">Insertion Sort</h1>\r\n                <p className=\"explanation\">This sort swaps each value backwards until it is less than the value previous, <i>inserting</i> it there. Then it starts over again with the next unsorted value until the array is sorted.</p>\r\n                <h3>Worst complexity:O(n^2)</h3>\r\n                <h3>Average complexity: O(n^2)</h3>\r\n                <h3>Best complexity: O(n)</h3>\r\n                <h3>Space complexity: O(1) </h3>\r\n            </div>)\r\n        })\r\n        var arrayBars = document.getElementsByClassName('array-bar');\r\n        for (let i = 1; i < arrayBars.length; i++) {\r\n            let j = i - 1;\r\n            console.log('outer' + i)\r\n            while (j >= 0 && parseInt(arrayBars[j + 1].style.height) < parseInt(arrayBars[j].style.height)) {\r\n                if (!executing) {\r\n                    this.setState({ disabledSlider: false })\r\n                    return\r\n                }\r\n                let temp1 = arrayBars[j + 1].style.height;\r\n                let temp2 = arrayBars[j].style.height;\r\n                arrayBars[j + 1].style.height = temp2;\r\n                arrayBars[j].style.height = temp1;\r\n                arrayBars[j].style.backgroundColor = 'red'\r\n                j -= 1\r\n                await sleep(50)\r\n            }\r\n        }\r\n        arrayBars[arrayBars.length - 1].style.backgroundColor = 'red'\r\n        this.setState({ disabledSlider: false })\r\n    }\r\n\r\n    async bubbleSort() {\r\n        await this.checkExecution()\r\n        this.setState({\r\n            title: (<div className=\"description\">\r\n                <h1 className=\"title\">Bubble Sort</h1>\r\n                <p className=\"explanation\">This sort loops through the array, every time it finds a value that is greater than the one previous, it swaps it forward. This <i>bubbles</i> the largest value up the to the top of the array.</p>\r\n                <h3>Worst complexity:O(n^2)</h3>\r\n                <h3>Average complexity: O(n^2)</h3>\r\n                <h3>Best complexity: O(n)</h3>\r\n                <h3>Space complexity: O(1) </h3>\r\n            </div>)\r\n        })\r\n        var arrayBars = document.getElementsByClassName('array-bar');\r\n        for (let i = 0; i < arrayBars.length - 1; i++) {\r\n            let b = 0;\r\n            console.log(`outer loop: ${i}`)\r\n            while (b < arrayBars.length - i - 1) {\r\n                if (!executing) {\r\n                    this.setState({ disabledSlider: false })\r\n                    return\r\n                }\r\n                console.log(`inner loop: ${b}`)\r\n                if (parseInt(arrayBars[b].style.height) > parseInt(arrayBars[b + 1].style.height)) {\r\n                    let temp1 = arrayBars[b].style.height;\r\n                    let temp2 = arrayBars[b + 1].style.height;\r\n                    arrayBars[b + 1].style.height = temp1;\r\n                    arrayBars[b].style.height = temp2;\r\n                }\r\n                arrayBars[b + 1].style.backgroundColor = SECONDARY_COLOR;\r\n                arrayBars[b].style.backgroundColor = PRIMARY_COLOR;\r\n                await sleep(this.state.AnimationSpeed)\r\n                ++b;\r\n            }\r\n        };\r\n        arrayBars[0].style.backgroundColor = 'red'\r\n        this.setState({ disabledSlider: false })\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className=\"gridContainer\">\r\n                <div className='display'>\r\n                    {this.state.title}\r\n                    <div className=\"slide-container\">\r\n                        <span className=\"slider\">\r\n                            <h2 className=\"slider-text barAmount\">Size of array to sort: {this.state.NUMBER_OF_ARRAY_BARS}</h2>\r\n                            <input className=\"slider-input number-of-bars\" type=\"range\" min=\"30\" max=\"200\" step=\"1\" disabled={this.state.disabledSlider} value={this.state.NUMBER_OF_ARRAY_BARS} onChange={(e) => { this.barAmount(e) }} />\r\n                        </span>\r\n                        <span className=\"slider\">\r\n                            <h2 className=\"slider-text barHeight\">Height of the array to sort: {this.state.barHeight}</h2>\r\n                            <input className=\"slider-input height-of-bars\" type=\"range\" min=\"100\" max=\"800\" step=\"1\" disabled={this.state.disabledSlider} value={this.state.barHeight} onChange={(e) => { this.barHeight(e) }} />\r\n                        </span>\r\n                        <span className=\"slider\">\r\n                            <h2 className=\"slider-text animationSpeed\">Animation Delay in miliseconds: {this.state.AnimationSpeed}</h2>\r\n                            <input className=\"slider-input animationSpeed\" type=\"range\" min=\"10\" max=\"500\" step=\"1\" disabled={this.state.disabledSlider} value={this.state.AnimationSpeed} onChange={(e) => { this.SetAnimationSpeed(e) }} />\r\n                        </span>\r\n                    </div>\r\n\r\n                    <div className=\"button-container\">\r\n                        <button className=\"generateNewArrayButton\" onClick={() => this.resetArray()}>Stop and Generate New Array</button>\r\n                        <button className=\"button\" onClick={() => this.bubbleSort()}>Bubble Sort</button>\r\n                        <button className=\"button\" onClick={() => this.insertionSort()}>insertionSort</button>\r\n                        <button className=\"button\" onClick={() => this.selectionSort()}>selectionSort</button>\r\n                        <button className=\"button\" onClick={() => this.mergeSort()}>Merge Sort</button>\r\n                        <button className=\"button\" onClick={() => this.quickSort()}>Quick Sort</button>\r\n                        {/* <button className=\"button\" onClick={() => this.heapSort()}>Heap Sort</button> */}\r\n                    </div>\r\n                </div>\r\n\r\n\r\n                <div className=\"array-container\">\r\n                    {this.state.array.map((value, idx) => (\r\n                        <div\r\n                            className=\"array-bar\"\r\n                            key={idx}\r\n                            style={{\r\n                                backgroundColor: \"turquoise\",\r\n                                height: `${value}px`,\r\n                            }}></div>\r\n                    ))}\r\n                </div>\r\n\r\n\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\n// From https://stackoverflow.com/questions/4959975/generate-random-number-between-two-numbers-in-javascript\r\nfunction randomIntFromInterval(min, max) {\r\n    // min and max included\r\n    return Math.floor(Math.random() * (max - min + 1) + min);\r\n}\r\n\r\nfunction arraysAreEqual(arrayOne, arrayTwo) {\r\n    if (arrayOne.length !== arrayTwo.length) return false;\r\n    for (let i = 0; i < arrayOne.length; i++) {\r\n        if (arrayOne[i] !== arrayTwo[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n","import React from 'react';\r\nimport SortingVisualizer from './SortingVisualizer/SortingVisualizer.js';\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <div className=\"container\">\r\n      <SortingVisualizer></SortingVisualizer>\r\n    </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}